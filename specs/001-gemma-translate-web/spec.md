# Feature Specification: TranslateGemma 網頁翻譯服務

**Feature Branch**: `001-gemma-translate-web`  
**Created**: 2026-02-17  
**Status**: Draft  
**Input**: User description: "建立一個類似 ChatGPT 對話介面的網頁翻譯服務，後端串接本地 TranslateGemma 模型（4B / 12B），讓使用者透過瀏覽器即可進行多語言文字翻譯。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - 基本文字翻譯 (Priority: P1)

使用者開啟網頁後，能夠在輸入框中輸入文字，點擊送出按鈕，系統顯示翻譯結果。這是最核心的功能，讓使用者能夠完成端到端的翻譯任務。

**Why this priority**: 這是服務的核心價值主張。沒有這個功能，整個服務將沒有實質意義。使用者必須能夠輸入文字並獲得翻譯結果。

**Independent Test**: 可以透過開啟網頁、輸入任意文字（如 "Hello World"）、點擊翻譯按鈕並驗證是否顯示翻譯結果來完整測試。這個測試不依賴任何其他功能。

**Acceptance Scenarios**:

1. **Given** 使用者開啟翻譯網頁，**When** 使用者在輸入框輸入文字並點擊送出，**Then** 系統應在 30 秒內顯示翻譯結果
2. **Given** 使用者已送出一次翻譯，**When** 使用者輸入新的文字並再次送出，**Then** 系統應在對話區域顯示新的翻譯結果
3. **Given** 使用者輸入超長文字（超過 1000 字元），**When** 送出翻譯請求，**Then** 系統應正常處理或顯示友善的錯誤訊息
4. **Given** 翻譯服務後端未啟動，**When** 使用者送出翻譯請求，**Then** 系統應在對話區域顯示清楚的錯誤訊息泡泡（如「無法連線至翻譯服務」）而非空白或崩潰

---

### User Story 2 - 語言選擇 (Priority: P2)

使用者能夠從下拉選單中選擇來源語言和目標語言，系統根據使用者選擇的語言對進行翻譯。

**Why this priority**: 雖然翻譯功能可以使用預設語言對運作，但使用者需要能夠自訂語言對才能滿足多樣化的翻譯需求。這是讓服務實際可用的關鍵功能。

**Independent Test**: 可以透過選擇不同語言對(如英文→中文、中文→英文)並驗證翻譯結果是否符合所選語言來獨立測試。

**Acceptance Scenarios**:

1. **Given** 使用者開啟網頁,**When** 使用者點擊語言下拉選單,**Then** 系統應顯示繁體中文(zh-TW)與英文(en)兩種語言選項
2. **Given** 使用者輸入英文文字（未手動選擇語言），**When** 送出翻譯請求，**Then** 系統應自動偵測為英文並翻譯成繁體中文
3. **Given** 使用者輸入繁體中文文字（未手動選擇語言），**When** 送出翻譯請求，**Then** 系統應自動偵測為繁體中文並翻譯成英文
4. **Given** 使用者手動選擇特定語言對，**When** 使用者輸入文字並送出，**Then** 系統應使用手動選擇的語言對而非自動偵測
5. **Given** 使用者選擇相同的來源和目標語言，**When** 送出翻譯請求，**Then** 系統應顯示友善提示或自動複製原文

---

### User Story 3 - 對話式介面與歷史記錄 (Priority: P3)

使用者的翻譯請求和結果以對話泡泡的形式呈現，類似聊天介面。使用者可以在當次瀏覽期間查看歷史翻譯記錄。

**Why this priority**: 對話式介面提升使用體驗，讓使用者能夠輕鬆追蹤多次翻譯的上下文。但即使沒有這個功能，使用者仍能完成基本翻譯任務。

**Independent Test**: 可以透過連續進行 3 次翻譯，並驗證所有翻譯記錄是否都保留在頁面上來獨立測試。

**Acceptance Scenarios**:

1. **Given** 使用者開啟網頁，**When** 使用者連續送出 3 次翻譯請求，**Then** 頁面應顯示全部 3 組原文與翻譯結果
2. **Given** 使用者已有多筆翻譯記錄，**When** 使用者向上捲動頁面，**Then** 使用者應能查看所有歷史翻譯記錄
3. **Given** 使用者已有翻譯記錄，**When** 使用者重新整理頁面或關閉瀏覽器，**Then** 所有翻譯記錄應被清除（不持久化）
4. **Given** 對話區域顯示多筆記錄，**When** 頁面佈局調整，**Then** 對話泡泡應保持「使用者輸入（原文）在右側、系統回應（譯文）在左側」的布局並保持可讀性

---

### User Story 4 - 串流輸出與複製功能 (Priority: P4)

翻譯結果以串流方式逐字逐句顯示，使用者能夠在翻譯完成後點擊複製按鈕將結果複製到剪貼簿。

**Why this priority**: 串流輸出和複製功能提升使用體驗和便利性，但不影響核心翻譯功能。使用者即使沒有這些功能也能完成翻譯任務。

**Independent Test**: 可以透過送出翻譯請求、觀察結果是否逐步顯示、點擊複製按鈕並檢查剪貼簿內容來獨立測試。

**Acceptance Scenarios**:

1. **Given** 使用者送出翻譯請求，**When** 後端開始回傳結果，**Then** 翻譯文字應以逐 token 方式逐步出現而非一次性顯示完整內容
2. **Given** 翻譯結果已完整顯示，**When** 使用者點擊複製按鈕，**Then** 翻譯文字應被複製到系統剪貼簿
3. **Given** 使用者複製翻譯結果，**When** 複製成功，**Then** 系統應顯示視覺回饋（如「已複製」提示）
4. **Given** 串流輸出過程中，**When** 網路連線中斷，**Then** 系統應顯示錯誤訊息並保留已接收的部分翻譯

---

### Edge Cases

- **空白輸入**：使用者未輸入任何文字或僅輸入空白字元就點擊送出時，系統應透過 Toast 通知顯示提示訊息（如「請輸入文字」）而非發送請求。輸入框為空時送出按鈕應自動禁用（FR-020）
- **特殊字元**：使用者輸入包含 emoji (如 😀🎉)、符號 (如 @#$%^&*)、換行符號 (\n) 的文字時，系統應正確處理並保留格式，翻譯結果應維持原始排版
- **超長文字**：使用者輸入超過 5000 字元時，系統應透過 Toast 通知顯示友善提示（「文字過長，請限制在 5000 字元以內」）並阻止送出
- **翻譯逾時**：模型推論超過 120 秒仍未完成時，系統應在對話區域顯示錯誤訊息泡泡並中斷請求（錯誤處理機制詳見 FR-017）。錯誤泡泡下方提供「重試」按鈕（FR-016a）
- **模型未載入**：後端服務啟動但模型尚未載入完成時，翻譯請求應在對話區域回傳錯誤訊息「模型初始化中，預計需要 30-60 秒，請稍候...」並每 5 秒自動輪詢健康檢查 API，當模型載入完成後自動提示使用者「模型已就緒，可以開始翻譯」（錯誤處理機制詳見 FR-017）
- **不支援的語言對**：使用者選擇的語言對模型不支援時，系統應透過 Toast 通知在送出前告知使用者（錯誤處理機制詳見 FR-017）
- **多視窗並行**：同一使用者在多個瀏覽器分頁/視窗同時使用服務時，每個視窗的翻譯記錄應獨立管理（Blazor WASM 預設行為）
- **來源與目標語言相同**：使用者手動選擇相同的來源和目標語言（如 zh-TW → zh-TW）時，系統應顯示 Toast 通知「來源與目標語言相同，請重新選擇」並阻止送出請求
- **串流輸出中斷**：若 SSE 串流在翻譯過程中中斷（網路斷線、逾時等），系統應在對話區域顯示錯誤泡泡「翻譯中斷，請重試」並保留已接收的部分譯文。系統不會自動重試，使用者需手動點擊「重試」按鈕重新發起請求（US4.4 已定義）
- **連續快速送出**：使用者在前一次翻譯未完成時再次點擊送出，系統應禁用送出按鈕（FR-021）防止重複請求。若使用者修改輸入文字，允許取消當前請求並發起新請求
- **後端回傳非預期格式**：若後端回傳非 JSON 或非符合 SSE 格式的資料，前端應在對話區域顯示錯誤訊息「無法解析伺服器回應，請聯繫管理員」並記錄詳細錯誤到瀏覽器 console
- **剪貼簿權限被拒絕**：若瀏覽器剪貼簿 API 不可用或權限被拒絕，複製按鈕應顯示 Toast 通知「無法存取剪貼簿，請手動選取文字複製」（詳見 FR-006a）

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: 系統必須提供文字輸入介面讓使用者輸入待翻譯文字
- **FR-001a**: 系統必須限制輸入文字長度不超過 5000 字元，並在超過限制時提供明確的錯誤提示
- **FR-001b**: 系統必須在輸入框下方即時顯示字數計數器，格式為「{current} / 5000 字元」，當輸入為空白時顯示「0 / 5000 字元」，超過限制時文字變為紅色警告
- **FR-002**: 系統必須提供來源語言和目標語言的選擇介面,**僅支援繁體中文(zh-TW)與英文(en)兩種語言**,不支援簡體中文或其他語言
- **FR-002a**: 系統必須提供自動語言偵測功能,當使用者未手動選擇語言時,自動偵測輸入文字的語言(僅支援繁體中文與英文偵測)。若偵測失敗或無法辨識,應預設為繁體中文輸入並透過 Toast 通知提示使用者「無法辨識語言,已預設為繁體中文→英文,可手動調整」
- **FR-002b**: 系統必須實作智能語言切換邏輯:偵測到繁體中文時自動設定目標語言為英文,偵測到英文時自動設定目標語言為繁體中文
- **FR-002c**: 系統必須支援使用者在輸入過程中（未送出前）動態切換語言選擇,切換時保留已輸入文字,並透過視覺回饋（下拉選單高亮）確認選擇
- **FR-003**: 系統必須在使用者送出翻譯請求後,將原文送至後端 API 進行翻譯
- **FR-004**: 系統必須以對話泡泡介面呈現翻譯結果,使用者輸入的原文顯示在右側,系統回應的譯文顯示在左側(符合現代聊天應用慣例)
- **FR-004a**: 對話泡泡視覺設計規格:
  - 使用者泡泡（原文）: 背景色 #E3F2FD（淺藍）、圓角 12px、內距 12px 16px、最大寬度 70%、靠右對齊
  - 系統泡泡（譯文）: 背景色 #F5F5F5（淺灰）、圓角 12px、內距 12px 16px、最大寬度 70%、靠左對齊
  - 泡泡間距: 垂直間距 12px、左右邊距 16px
  - 字體: 使用系統預設無襯線字體、大小 14px、行高 1.5、顏色 #212121（深灰）
- **FR-005**: 系統必須支援串流方式接收並顯示翻譯結果，串流顆粒度為逐 token（模型輸出的最小單位）。每個 token 顯示時無淡入動畫，直接出現（符合 ChatGPT 即時串流行為）
- **FR-005a**: 系統必須在翻譯開始後 1 秒內顯示載入動畫（訊息泡泡內的脈動效果），在接收到第一個 token 後立即顯示文字。若翻譯時間超過 30 秒，應在泡泡內顯示進度提示「翻譯中...（已等待 {elapsed} 秒）」
- **FR-006**: 系統必須在翻譯結果旁提供複製按鈕，讓使用者能一鍵複製翻譯文字
- **FR-006a**: 複製按鈕視覺狀態設計:
  - 預設狀態: 圖示為複製符號（📋）、顏色 #757575（中灰）、圓角 4px、內距 4px
  - hover 狀態: 背景色 #E0E0E0、圖示顏色 #424242
  - active 狀態: 背景色 #BDBDBD、短暫縮放效果（scale 0.95）
  - 成功狀態: 圖示變為勾選符號（✓）、顏色 #4CAF50（綠色）、顯示 2 秒後復原
  - 錯誤狀態: 若剪貼簿權限被拒絕，顯示 Toast 通知「無法存取剪貼簿，請手動選取文字複製」，按鈕保持可見但 hover 時顯示提示訊息
  - **技術實作**: 使用瀏覽器原生 `navigator.clipboard.writeText()` API（支援 Chrome 66+, Firefox 63+, Safari 13.1+, Edge 79+）。若 API 不可用或返回錯誤，使用 fallback 方法：
    1. 創建臨時 `<textarea>` 元素
    2. 設定 `textarea.value` 為翻譯文字
    3. 呼叫 `textarea.select()` 選取內容
    4. 執行 `document.execCommand('copy')` 複製
    5. 移除臨時 `<textarea>`
    6. 若 fallback 也失敗，顯示 Toast 錯誤並高亮顯示翻譯文字（提示使用者手動選取）
- **FR-007**: 系統必須在當次瀏覽期間保留所有翻譯記錄於記憶體中，不做持久化儲存
- **FR-008**: 系統必須在使用者重新整理頁面或關閉瀏覽器時清除所有翻譯記錄
- **FR-009**: 系統必須支援桌面與行動裝置的響應式佈局，測試斷點為：手機 (<768px)、平板 (768-1279px)、桌面 (≥1280px)。所有裝置必須維持可讀性基準：
  - 最小可點擊區域：44x44 像素（按鈕、下拉選單）
  - 最小文字大小：14px（對話泡泡內容）、12px（次要資訊如字數計數器）
  - 最小行高：1.5（確保多行文字可讀性）
  - 對話泡泡在小螢幕（<768px）時最大寬度調整為 85%（避免過窄）
- **FR-010**: 後端必須提供翻譯 API 端點，接收原文、來源語言碼、目標語言碼並回傳翻譯結果
- **FR-011**: 後端必須支援 Server-Sent Events (SSE) 串流回應方式
- **FR-012**: 後端必須提供語言清單 API 端點，回傳系統支援的所有語言及其語言碼
- **FR-013**: 後端必須提供健康檢查 API 端點，回傳服務狀態、載入的模型名稱及推論裝置資訊
- **FR-014**: 後端必須透過設定檔載入模型配置，包含模型選擇（4B 或 12B）、裝置選擇（CPU / CUDA / MPS）、資料型別等參數
- **FR-015**: 後端必須支援在 Apple MPS、NVIDIA CUDA、CPU 三種裝置上進行模型推論
- **FR-016**: 系統必須在翻譯請求超過設定的 timeout（預設 120 秒）時中斷處理並回傳逾時錯誤，錯誤訊息格式為「翻譯逾時（已等待 {elapsed} 秒），請稍後重試」
- **FR-016a**: 系統必須在翻譯逾時錯誤泡泡下方提供「重試」按鈕，點擊後使用相同原文重新發起翻譯請求，保留原始語言對設定
- **FR-017**: 系統必須提供雙層錯誤訊息顯示機制：輕量錯誤（如空白輸入、格式驗證失敗）透過 Toast 通知顯示 5 秒後自動消失；嚴重錯誤（如翻譯失敗、後端無回應、逾時）在對話區域顯示錯誤訊息泡泡並保留在歷史記錄中
- **FR-017a**: 錯誤訊息泡泡視覺設計規格：
  - 背景色：#FFEBEE（淺紅）、圓角 12px、內距 12px 16px、最大寬度 70%、靠左對齊
  - 圖示：⚠️ 警告符號、顏色 #C62828（暗紅）
  - 字體：使用系統預設無襯線字體、大小 14px、行高 1.5、顏色 #B71C1C（深紅）
  - 錯誤訊息應簡潔明確，包含可操作建議（如「請檢查網路連線」）
- **FR-018** (可選): 系統可支援自訂術語對照表功能，透過後端 config.yaml 設定檔管理。當配置檔包含 `glossary.enabled: true` 及 `glossary.entries` 區塊時，翻譯時**絕對優先**直接替換匹配的術語（不依賴模型判斷）；若模型輸出與術語對照表衝突，以術語對照表為準。若配置檔中術語對照表內容被註解或 `enabled: false`，則忽略此功能
- **FR-019**: 系統必須在使用者首次開啟網頁時顯示初始引導畫面，包含:
  - 歡迎訊息:「歡迎使用 TranslateGemma 翻譯服務」
  - 簡短說明:「支援繁體中文 ↔ 英文互譯，請在下方輸入文字開始翻譯」
  - 輸入框已取得焦點，可直接開始輸入
  - 當使用者開始輸入或已有翻譯記錄時，引導畫面不再顯示
- **FR-020**: 系統必須在輸入框為空白時自動禁用（disable）送出按鈕，並顯示灰色樣式；當輸入內容後立即啟用按鈕並恢復正常顏色
- **FR-021**: 系統必須防止使用者在翻譯進行中重複送出請求，送出後禁用送出按鈕並改為「翻譯中...」狀態，直到翻譯完成或錯誤發生
- **FR-022**: 系統必須限制前端翻譯記錄保留數量，預設最多保留最新 50 筆記錄（包含成功與錯誤記錄），超過數量時自動刪除最舊記錄（FIFO 輪替）。此限制可透過前端設定修改（未來可擴充為使用者偏好設定）
### Key Entities

- **翻譯請求 (TranslationRequest)**: 代表單次翻譯任務,包含原文文字、來源語言碼、目標語言碼、是否使用串流輸出、可選的術語對照表
- **翻譯回應 (TranslationResponse)**: 代表翻譯結果,包含翻譯後文字、來源語言碼、目標語言碼
- **語言 (Language)**: 代表系統支援的語言,包含語言碼(如 "en"、"zh-TW")和語言名稱(如 "English"、"Traditional Chinese")。僅支援繁體中文與英文,不支援簡體中文或其他語言
- **翻譯記錄 (TranslationHistory)**: 代表使用者的歷史翻譯,包含原文、譯文、語言對、時間戳記,僅存在於瀏覽器記憶體中
- **術語對照表 (TerminologyGlossary)**: 代表使用者自訂的詞彙翻譯對應,包含原文詞彙、對應譯文、語言對,僅存在於瀏覽器記憶體中

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 使用者能在 30 秒內完成單次文字翻譯（使用 4B 模型），60 秒內完成翻譯（使用 12B 模型）
  - **驗證方法**: 自動化測試（Playwright）
    1. 測試環境：後端使用 4B 模型 + CUDA/MPS 裝置
    2. 輸入 "Hello, how are you?" (17 字元)
    3. 點擊翻譯按鈕，記錄開始時間
    4. 等待譯文顯示，記錄結束時間
    5. 驗證總時間 < 30 秒
    6. 重複測試 12B 模型，驗證 < 60 秒
- **SC-002**: 系統支援最新版本的 Chrome、Firefox、Safari、Edge 瀏覽器訪問，能完成完整翻譯流程（輸入→送出→顯示結果）且無崩潰或白畫面
  - **驗證方法**: 手動測試 + 跨瀏覽器自動化測試
    1. 在 Chrome/Firefox/Safari/Edge 最新版各開啟網頁
    2. 輸入 "Test translation" 並送出
    3. 驗證顯示譯文且無 console 錯誤
    4. 測試複製按鈕、語言選擇等互動功能
    5. 驗證無白畫面或 UI 失真
- **SC-003**: 使用者能在桌面電腦（≥1280px）、平板（768-1279px）、手機（<768px）等不同裝置上完成翻譯任務，介面保持可讀性與可操作性
  - **驗證方法**: 手動測試 + 響應式模擬
    1. Chrome DevTools 設定為 iPhone SE (375x667)，驗證對話泡泡寬度 85%、按鈕至少 44x44px
    2. 設定為 iPad (768x1024)，驗證雙欄布局正常
    3. 設定為 Desktop (1920x1080)，驗證對話泡泡最大寬度 70%
    4. 在每個尺寸完成翻譯流程，驗證功能正常
- **SC-004**: 95% 的正常翻譯請求（文字長度 < 500 字元）能在 20 秒內回傳第一個 token
  - **驗證方法**: 效能測試（後端整合測試）
    1. 準備 100 個 < 500 字元的測試文字（中英文混合）
    2. 使用 pytest 連續呼叫 POST /api/translate
    3. 記錄每次請求到接收第一個 SSE token 的時間
    4. 計算 P95 值，驗證 < 20 秒
    5. 驗證至少 95 個請求符合時間要求
- **SC-005**: 系統能透過 Docker/Podman Compose 在 5 分鐘內完成一鍵部署並啟動服務
  - **部署步驟**（不包含模型下載時間）：
    1. 複製 `config.example.yaml` 為 `config.yaml` 並設定模型路徑
    2. 執行 `docker-compose up -d` 或 `podman-compose up -d`
    3. 等待容器啟動與模型載入（預計 30-60 秒）
    4. 驗證服務：`curl http://localhost:8000/health` 回傳 `model_loaded: true`
    5. 開啟瀏覽器訪問 `http://localhost:5000`
  - **前置條件**: 模型檔案已下載完成並放置在 `models/` 目錄，下載時間不計入 5 分鐘內
  - **驗證方法**: 從空白環境（已下載模型）執行上述步驟，計時從 `docker-compose up` 到網頁可存取
- **SC-006**: 使用者能在不修改程式碼的情況下，透過修改設定檔切換不同模型（4B / 12B）和推論裝置（CPU / CUDA / MPS）
  - **操作步驟**: 
    1. 編輯 `config.yaml` 修改 `model.name` 和 `model.device` 參數
    2. 重啟後端服務（`docker-compose restart backend` 或 `systemctl restart translategemma`）
  - **重啟原因**: 模型佔用記憶體較大，切換模型需釋放舊模型並載入新模型，為保證穩定性與資源清理完整，必須重啟服務
  - **驗證方法**: 
    1. 修改 `config.yaml` 將 `model.name` 從 `Translategemma-4b-it` 改為 `Translategemma-12b-it`
    2. 重啟後端服務
    3. 呼叫 `/health` 端點驗證 `model` 欄位為 `Translategemma-12b-it`
    4. 執行翻譯請求驗證功能正常
- **SC-007**: 串流輸出的翻譯結果能在 1 秒內開始逐步顯示（而非等待完整翻譯完成）
  - **驗證方法**: 自動化 UI 測試（Playwright）
    1. 輸入 "Hello, world!" 並送出
    2. 記錄送出時間 T0
    3. 使用 DOM 監視器偵測第一個字元出現在對話泡泡的時間 T1
    4. 驗證 (T1 - T0) < 1 秒
    5. 持續監視 DOM 變化，驗證譯文逐token顯示
- **SC-008**: 使用者能在翻譯完成後 1 次點擊內完成結果複製動作
  - **驗證方法**: 手動測試 + 自動化測試
    1. 完成一次翻譯
    2. 點擊複製按鈕（僅 1 次點擊）
    3. 驗證剪貼簿內容與翻譯結果一致（`navigator.clipboard.readText()` 或手動貼上）
    4. 驗證複製按鈕顯示成功狀態（✓ 綠色）
- **SC-009**: 系統能在後端模型未載入或發生錯誤時，向使用者顯示清楚的錯誤訊息而非空白或崩潰
  - **驗證方法**: 故障模擬測試
    1. 停止後端服務，開啟前端網頁
    2. 驗證顯示錯誤泡泡「無法連線至翻譯服務」
    3. 啟動後端但模型未載入，驗證顯示「模型初始化中」 + 輪詢提示
    4. 輸入超長文字，驗證顯示 Toast 「文字過長」
    5. 驗證所有錯誤訊息符合 data-model.md 错誤格式規範

## Non-Functional Requirements *(Phase B)*

### Performance Requirements

- **NFR-001**: 前端首次載入時間：Blazor WASM bundle 載入與啟動應在 3 秒內完成（測量從瀏覽器請求 index.html 到首次渲染完成）
- **NFR-002**: 前端頁面切換時間：使用者操作（如展開語言選單、點擊複製按鈕）應在 100 毫秒內有視覺回饋
- **NFR-003**: SSE 串流首 token 延遲：95% 的正常請求（< 500 字元）應在 20 秒內開始回傳第一個 token（對應 SC-004）
- **NFR-004**: 翻譯記錄渲染效能：當翻譯記錄超過 50 筆時，對話區域應啟用虛擬滾動（Virtual Scrolling）避免效能下降

### Security Requirements

- **NFR-005**: 輸入驗證：前後端必須驗證所有使用者輸入，防止 XSS 注入攻擊
  - 前端：Blazor 自動轉義 HTML 字元
  - 後端：Pydantic 驗證資料型別與長度
- **NFR-006**: API Rate Limiting（可選實作）：建議在生產環境透過 reverse proxy（如 nginx）實作每 IP 限制：
  - 每分鐘最多 30 次翻譯請求
  - 超過限制回傳 HTTP 429（Too Many Requests）
  - **Note**: 本地開發環境可不實作此限制
  - **多視窗並發策略**: Blazor WASM 多視窗獨立運作，無需前端全域狀態限制，所有並發控制交由後端 Rate Limiting 處理（同標籤頁多視窗共享 IP 限制）
- **NFR-007**: HTTPS/TLS 傳輸加密：
  - **開發環境**: 允許使用 HTTP（localhost 豁免）
  - **生產環境**: 強烈建議透過 reverse proxy（如 nginx）處理 TLS 終止
  - 後端服務本身無需實作 HTTPS（由 reverse proxy 負責）
- **NFR-008**: CORS 政策：
  - **開發環境**: 允許 `http://localhost:*` 和 `http://127.0.0.1:*`
  - **生產環境**: 僅允許明確的前端部署網域白名單（透過後端 `config.yaml` 配置）
  - **部署假設**: 預設假設前後端部署在不同網域（跨域），需啟用 CORS。若同域部署（如 reverse proxy 合併服務）可在 `config.yaml` 設定 `cors.enabled: false` 禁用 CORS
  - 範例配置:
    ```yaml
    cors:
      enabled: true  # 跨域時啟用
      allowed_origins:
        - "https://translate.example.com"
        - "https://app.example.com"
    ```
- **NFR-009**: 依賴掃描：建議定期執行依賴漏洞掃描：
  - Python: `pip-audit`
  - .NET: `dotnet list package --vulnerable`

### Reliability Requirements

- **NFR-010**: SSE 串流重連策略：
  - 前端使用瀏覽器原生 `EventSource` API（自動具備重連機制）
  - 自訂重連邏輯（若需要）：
    - 最多嘗試 3 次重連
    - 重連間隔：1 秒 → 3 秒 → 9 秒（指數退避）
    - 3 次失敗後顯示錯誤泡泡「無法連線至翻譯服務」
- **NFR-011**: 健康檢查輪詢策略：
  - **初次載入**: 前端開啟時執行一次健康檢查（`GET /api/health`）
  - **模型未就緒**: 若回傳 `model_loaded: false`，每 5 秒輪詢一次直到 `model_loaded: true`
  - **模型就緒提示**: 當模型從未就緒變為就緒時，顯示 Toast 成功通知「模型已就緒，可以開始翻譯」
  - **背景輪詢**: 初次就緒後停止輪詢，僅在收到「模型初始化中」錯誤時重新啟動輪詢
  - **後端重啟偵測**: 若翻譯請求回傳 HTTP 503 或連線錯誤，前端應自動觸發健康檢查輪詢（每 5 秒一次），當後端恢復時顯示 Toast 通知「服務已恢復，請重試」
- **NFR-012**: 請求逾時設定：
  - 前端 fetch timeout: 130 秒（略長於後端 timeout 以接收完整錯誤訊息）
  - 後端推論 timeout: 120 秒（對應 FR-016）
- **NFR-013**: 服務降級策略：
  - **無降級機制**: 當後端資源不足或模型推論過慢時，直接回傳 HTTP 503（Service Unavailable）錯誤
  - **使用者操作**: 顯示錯誤泡泡「翻譯服務暫時無法使用，請稍後重試」，使用者可手動重試
  - **Rationale**: MVP 階段無需複雜的降級邏輯（如請求佇列、模型切換），保持系統簡單

### Observability Requirements

- **NFR-014**: 後端日誌記錄範圍：
  - **INFO 級別**: 服務啟動、模型載入完成、API 請求摘要（語言對、字元數、處理時間）
  - **ERROR 級別**: 模型載入失敗、推論逾時、非預期例外
  - **日誌格式**: 結構化 JSON 格式（便於後續整合 ELK/Loki）
  - **範例**:
    ```json
    {
      "timestamp": "2026-02-18T10:30:45.123Z",
      "level": "INFO",
      "event": "translation_completed",
      "source_lang": "en",
      "target_lang": "zh-TW",
      "char_count": 256,
      "duration_ms": 3421
    }
    ```
- **NFR-015**: 效能監控指標（建議實作）：
  - **回應時間**: P50、P95、P99 翻譯時間（從接收請求到完成串流）
  - **錯誤率**: 每小時 5xx 錯誤數量與比例
  - **資源使用**: GPU/CPU 使用率、記憶體佔用（透過系統監控工具如 Prometheus）
  - **Note**: 初期可透過日誌分析實作，未來可整合 Prometheus + Grafana
- **NFR-016**: 前端錯誤追蹤：
  - 所有未預期錯誤（如後端回傳格式錯誤、SSE 解析失敗）記錄到瀏覽器 console
  - 記錄格式:
    ```js
    console.error('[TranslateGemma] 錯誤類型: invalid_response', {
      url: '/api/translate',
      status: 502,
      body: '<html>Bad Gateway</html>'
    });
    ```

### Accessibility Requirements

- **NFR-017**: 無障礙支援範圍（MVP 階段）：
  - **不強制要求**: 本階段無需完整符合 WCAG 2.1 AA 標準
  - **基礎支援**: MudBlazor 元件庫提供預設的無障礙特性（語意化 HTML、基礎 ARIA 標籤）
  - **JavaScript 必須**: Blazor WASM 必須啟用 JavaScript，無法提供 fallback。應在 `index.html` 中補充 `<noscript>` 標籤提示使用者啟用 JavaScript：
    ```html
    <noscript>
      <div style="text-align: center; padding: 40px; font-family: sans-serif;">
        <h1>⚠️ 需要啟用 JavaScript</h1>
        <p>此應用程式需要 JavaScript 才能運作。</p>
        <p>請在瀏覽器設定中啟用 JavaScript 後重新載入頁面。</p>
      </div>
    </noscript>
    ```
  - **未來改進**: Phase 2 可考慮：
    - 鍵盤導航（Tab 切換輸入框/按鈕、Enter 送出）
    - 螢幕閱讀器支援（完整 ARIA 標籤）
    - 色彩對比度符合 WCAG 2.1 AA（4.5:1 for 正常文字）

### Maintainability Requirements

- **NFR-018**: 設定檔參數規範：
  - 後端 `config.yaml` 必須明確定義所有可調整參數：
    ```yaml
    model:
      name: "Translategemma-4b-it"  # 或 "Translategemma-12b-it"
      device: "auto"  # auto | cuda | mps | cpu
      dtype: "float32"  # float32 | float16 | bfloat16 | int8
      path: "./models/Translategemma-4b-it"
    
    translation:
      timeout: 120  # 秒
      max_length: 5000  # 字元
    
    server:
      host: "0.0.0.0"
      port: 8000
    
    cors:
      allowed_origins:
        - "http://localhost:5000"
    ```
  - **資料型別說明**:
    - `float32`: 預設精度，最高品質（記憶體需求高）
    - `float16`: 半精度，速度快 2 倍（記憶體減半，品質略降）
    - `bfloat16`: Brain Float 16，平衡速度與品質（NVIDIA A100/H100 最佳）
    - `int8`: 8-bit 量化，記憶體最小（品質顯著下降，僅推薦 CPU 環境）
- **NFR-019**: 備份與還原策略：
  - **無資料庫**: 本服務無持久化資料，無需資料備份
  - **配置檔備份**: 建議生產環境定期備份 `config.yaml`（版本控制或自動化腳本）
  - **模型檔案**: 模型檔案應從 Hugging Face 官方下載，必要時可透過 Git LFS 或對象儲存進行備份

---

## Clarifications

### Session 2026-02-17

- Q: 輸入文字長度限制：規格中提到「超長文字（超過 1000 字元）」和「超過模型處理上限」，但沒有明確定義實際的字元數上限。實際的硬性字元數上限應該是多少？ → A: 5000 字元（長文檔，可能較慢）
- Q: 預設語言對：當使用者首次開啟網頁時，來源語言和目標語言的預設值應該是什麼？ → A: 輸入中文則翻譯英文，輸入英文則翻譯中文（先不考慮其他語言）- 系統應自動偵測輸入語言並智能切換目標語言
- Q: 串流輸出顆粒度：規格提到「翻譯結果以串流方式逐字逐句顯示」，但沒有明確串流的顆粒度（逐 token / 逐詞 / 逐句）。實際的串流顆粒度應該是什麼？ → A: 逐 token（模型輸出單位，最即時）
- Q: 對話泡泡布局方向：規格提到「對話泡泡應左右對齊（原文左，譯文右）」，但這與常見的對話介面習慣可能有衝突。實際的視覺布局邏輯應該是什麼？ → A: 使用者輸入（原文）右、系統回應（譯文）左 - 符合現代聊天應用慣例
- Q: 錯誤訊息的顯示方式與持續時間：規格提到多種錯誤情境（後端未啟動、模型未載入、翻譯逾時、空白輸入等），但沒有說明錯誤訊息應該如何顯示以及何時消失。錯誤訊息的顯示策略應該是什麼？ → A: Toast 通知（3-5 秒自動消失）+ 對話區域錯誤訊息 - 輕量錯誤用 Toast，嚴重錯誤在對話區域顯示保留歷史

### Session 2026-02-18 (Phase B - NFR補充)

- Q: 前端如何呼叫健康檢查 API？是否需要定期輪詢？ → A: 僅在模型未載入時每 5 秒輪詢，首次載入和背景正常運作時不輪詢（避免無謂請求）
- Q: 是否需要符合 WCAG 2.1 AA 無障礙標準？ → A: MVP 階段不強制要求，使用 MudBlazor 預設無障礙支援即可，Phase 2 再考慮完整無障礙性
- Q: 是否強制要求 HTTPS？ → A: 僅建議生產環境使用（透過 nginx），本地開發可用 HTTP
- Q: 當後端過載時是否需要降級策略（如請求佇列）？ → A: 無降級機制，直接回傳 503 錯誤讓使用者手動重試（保持系統簡單）

### Session 2026-02-18 (Phase C - 邊界案例與細節)

- Q: 串流輸出中斷後是否需要自動重試機制？ → A: 無自動重試，顯示錯誤泡泡「翻譯中斷，請重試」並保留部分譯文，使用者手動重試（US4.4 已定義）
- Q: 模型切換（4B ↔ 12B）時是否需要重啟服務？ → A: 需要重啟服務，因模型佔用記憶體較大，重啟可確保穩定性與資源清理完整
- Q: 術語對照表與模型翻譯結果衝突時如何處理？ → A: 術語對照表絕對優先，直接替換模型輸出的詞彙，不依賴模型判斷
- Q: 「逐 token 方式逐步出現」是否需要定義淡入動畫時長？ → A: 無淡入動畫，直接出現符合 ChatGPT 即時串流行為
- Q: Toast 通知「3-5 秒自動消失」應固定值還是動態調整？ → A: 固定 5 秒，簡單易懂不增加複雜度
- Q: 「清楚的錯誤訊息泡泡」是否需要具體視覺規格？ → A: 需要，新增 FR-017a 定義錯誤泡泡配色（淺紅 #FFEBEE）、圖示（⚠️）、字體規格
- Q: US2.5「友善提示或自動複製原文」應採用哪種策略？ → A: 採用 Toast 提示「來源與目標語言相同，請重新選擇」並阻止送出
- Q: US3.4「保持可讀性」是否需要量化標準？ → A: 需要，補充至 FR-009：最小可點擊區域 44x44px、最小文字 14px、行高 1.5
- Q: SC-005「一鍵部署」包含哪些步驟？ → A: 5 分鐘不包含模型下載，僅包含 docker-compose up、模型載入、驗證服務（共 5 步驟）
- Q: 翻譯記錄達到極大數量時的限制策略？ → A: 新增 FR-022 限制最多保留最新 50 筆記錄（可配置），超過時 FIFO 輪替
- Q: 後端服務重啟時前端的偵測與提示機制？ → A: 補充至 NFR-011，翻譯請求返回 503 時自動觸發健康檢查輪詢（每 5 秒），恢復後 Toast 通知
- Q: 不支援的語言對錯誤是否在前端阻擋？ → A: 是，FR-002 前端僅顯示 zh-TW/en，隱含前端阻擋，補充說明至 Edge Cases
- Q: 多視窗並行時的並發請求數量限制？ → A: 無前端限制，交由後端 Rate Limiting 處理（NFR-006），多視窗共享 IP 限制
- Q: 是否假設使用者瀏覽器已啟用 JavaScript？ → A: 是，Blazor WASM 必須 JS，補充 `<noscript>` 提示至 NFR-017
- Q: 是否假設後端與前端部署在相同網域？ → A: 預設假設跨域（不同埠），NFR-008 補充可在 config.yaml 設定 `cors.enabled: false` 同域部署
- Q: 剪貼簿 API 不可用時的替代方案？ → A: 補充至 FR-006a，使用 `document.execCommand('copy')` fallback，若都失敗則高亮顯示文字提示手動選取
- Q: 是否為每個 Success Criteria 定義驗證方法？ → A: 是，所有 SC-001~009 已補充自動化/手動測試驗證方法
- Q: 術語表是否需要建立 glossary.md 統一專業名詞？ → A: 文件用詞已一致，改為在 config.yaml 提供術語對照表範例，註解時程式端忽略此功能